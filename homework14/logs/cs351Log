

////////////////////////////////
New run at Wed Dec 11 13:19:54 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		//TODO: return the size of the queue
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		//TODO: return whether the queue is empty
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:20:32 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		//TODO: return the size of the queue
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		//TODO: return whether the queue is empty
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:25:40 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		//TODO: return the size of the queue
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		//TODO: return whether the queue is empty
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:27:42 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return data.length;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (data.length==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:27:52 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return data.length;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (data.length==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:27:55 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return data.length;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (data.length==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Wed Dec 11 13:28:43 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return data.length;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (data.length==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 10:28:24 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems > 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(data[i])) {
				
			}
		}
		
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (ProfileLink p) {
		
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 10:28:26 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems > 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(data[i])) {
				
			}
		}
		
		return true;
	}
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (ProfileLink p) {
		
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:44:38 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems > 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:45:08 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems > 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:45:37 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems >= 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:45:46 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (!(manyItems >= 0 && manyItems < data.length)) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:46:21 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>=data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:46:48 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0 || 
			comp.compare(arr[i], arr[i*3+2])>0 || 
			comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:48:08 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (arr[i*3+1]!=null &&comp.compare(arr[i], arr[i*3+1])>0 || 	
			arr[i*3+2]!=null && comp.compare(arr[i], arr[i*3+2])>0 || 
			arr[i*3+3]!=null && comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:48:32 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (arr[i*3+1]!=null &&comp.compare(arr[i], arr[i*3+1])>0 || 	
			arr[i*3+2]!=null && comp.compare(arr[i], arr[i*3+2])>0 || 
			arr[i*3+3]!=null && comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:48:38 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (arr[i*3+1]!=null &&comp.compare(arr[i], arr[i*3+1])>0 || 	
			arr[i*3+2]!=null && comp.compare(arr[i], arr[i*3+2])>0 || 
			arr[i*3+3]!=null && comp.compare(arr[i], arr[i*3+3])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Thu Dec 12 13:50:00 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node
	
	private boolean child (int i, ProfileLink [] arr, Comparator <ProfileLink> comp) {
		if (comp.compare(arr[i], arr[i*3+1])>0) {
			return false;
		}
		return true;
	}
	
	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:14:09 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length && comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:14:56 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i] !=null && comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i] !=null && comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i] !=null && comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:15:26 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:15:41 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:16:17 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:17:01 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length &&  && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:17:05 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length  && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:17:19 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:18:58 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Fri Dec 13 13:19:02 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 16:28:48 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 16:28:54 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 16:29:14 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 16:29:17 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 16:29:42 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 19:13:40 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((i * 3 + 1) < arr.length  && arr[i * 3 + 1] !=null && 
				comp.compare(arr[i], arr[i * 3 + 1]) > 0)
			return false;
		else if ((i * 3 + 2) < arr.length && arr[i * 3 + 2] !=null && 
				comp.compare(arr[i], arr[i * 3 + 2]) > 0)
			return false;
		else if ((i * 3 + 3) < arr.length && arr[i * 3 + 3] !=null && 
				comp.compare(arr[i], arr[i * 3 + 3]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
		
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:13:18 CST 2019

PriorityQueue.java

package edu.uwm.cs351;

import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				comp.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				comp.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				comp.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		//TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null) throw new IllegalArgumentException("Profile link is null");
        data[manyItems] = l; 
        int i = manyItems; 
  
        while (data[i] < data[i-1/3]) { 
            swap(i,); 
            current = parent(current); 
        }
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	private ProfileLink bubbleUp (ProfileLink a ) {
		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) {
		return (i-1)/3;
	}
	
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:14:49 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				comp.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				comp.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				comp.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		data[manyItems] = l;
		int i = manyItems;

		while (data[i] < data[parent(i)]) {
			swap(i, parent(i));
			i = parent(i);
		}
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	private ProfileLink bubbleUp (ProfileLink a ) {
		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) {
		return (i-1)/3;
	}
	
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:16:14 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data, COMP)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr, Comparator<ProfileLink> comp) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				comp.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				comp.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				comp.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l, Comparator<ProfileLink> comp) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		data[manyItems] = l;
		int i = manyItems;

		while (comp.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		
		return true;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	//    bubbleDown
	//    bubbleUp
	//    other useful utility methods?
	
	private ProfileLink bubbleUp (ProfileLink a ) {
		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) {
		return (i-1)/3;
	}
	
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:31:28 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:32:01 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:32:04 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:33:12 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		if (manyItems+1==data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:34:09 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		if (manyItems+1==data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:34:13 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		if (manyItems+1==data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		ProfileLink returning = data[0];
		
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:35:15 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		if (manyItems+1==data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:35:18 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		if (manyItems+1==data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:35:35 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:35:37 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:35:53 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])>0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 20:36:48 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		
		
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	
	private ProfileLink bubbleUp (ProfileLink a, int i) {

		return null;
	}
	
	private ProfileLink bubbleDown(ProfileLink a) {
		return null;
	}
	
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 
	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 21:11:57 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	//TODO: optional helper methods
	private void bubbleDown(int i) {
		if (data[i] != null) {
			if (COMP.compare(data[i], data[left(i)]) < 0 || COMP.compare(data[i], data[right(i)]) < 0) {
				if (COMP.compare(data[left(i)], data[right(i)]) < 0) {
					swap(i, left(i));
					bubbleDown(left(i));
				}

				else {
					swap(i, right(i));
					bubbleDown(right(i));
				}
			}
		}
	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:09:59 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (data[left(i)] == null || data[mid(i)] == null 
				|| data[right(i)] == null) {
			swap(0, i);
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));
		
	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:33:16 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if (COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (COMP.compare(data[i], data[right(i)]) < 0) {
			swap (i, right(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));
		
	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:33:20 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if (COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (COMP.compare(data[i], data[right(i)]) < 0) {
			swap (i, right(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));
		
	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:34:28 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if (data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:36:13 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:38:50 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:39:10 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i, ProfileLink[] arr) {
		if ((left(i)) < arr.length  && arr[left(i)] !=null && 
				COMP.compare(arr[i], arr[left(i)]) > 0)
			return false;
		else if ((mid(i)) < arr.length && arr[mid(i)] !=null && 
				COMP.compare(arr[i], arr[mid(i)]) > 0)
			return false;
		else if ((right(i)) < arr.length && arr[right(i)] !=null && 
				COMP.compare(arr[i], arr[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:51:28 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:51:40 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:51:57 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i, data)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:52:11 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:52:17 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:52:25 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:53:22 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:53:27 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} else {
			manyItems--;
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:54:27 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			manyItems--;
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			manyItems--;
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			manyItems--;
			swap(i, right(i));
		} else {
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:54:52 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (data[i]==null);
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			manyItems--;
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			manyItems--;
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			manyItems--;
			swap(i, right(i));
		} else {
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:55:00 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (data[i]==null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			manyItems--;
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			manyItems--;
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			manyItems--;
			swap(i, right(i));
		} else {
			return;
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:56:05 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
			manyItems--;
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
			manyItems--;
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
			manyItems--;
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:56:27 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
			manyItems--;
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
			manyItems--;
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
			manyItems--;
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:57:32 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
			manyItems--;
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
			manyItems--;
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
			manyItems--;
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:58:33 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sat Dec 14 23:58:55 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, left(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, mid(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, right(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:01:39 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:01:45 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:02:06 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:02:14 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:02:17 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:04:31 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i > data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:05:41 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:05:48 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:08:29 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:09:41 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null && COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null && COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null && COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:10:55 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null 
				&& COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null 
				&& COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null 
				&& COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:11:02 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if ((left(i)) < data.length && data[left(i)] != null 
				&& COMP.compare(data[i], data[left(i)]) < 0) {
			swap(i, parent(i));
		} else if ((mid(i)) < data.length && data[mid(i)] != null 
				&& COMP.compare(data[i], data[mid(i)]) < 0) {
			swap(i, parent(i));
		} else if (right(i) < data.length && data[right(i)] != null 
				&& COMP.compare(data[i], data[right(i)]) < 0) {
			swap(i, parent(i));
		} 
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:13:43 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:14:11 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:15:27 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:16:24 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:16:28 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:16:31 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:18:05 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
	//	bubbleDown(mid(i));
		//bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:18:14 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		//bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:18:21 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}


////////////////////////////////
New run at Sun Dec 15 00:19:57 CST 2019

PriorityQueue.java

package edu.uwm.cs351;
//Looked at tips from geeks for geeks website
import edu.uwm.cs351.util.Profile;
import edu.uwm.cs351.util.ProfileLink;

import java.util.Arrays;
import java.util.Comparator;
import java.util.NoSuchElementException;

import junit.framework.TestCase;
import snapshot.Snapshot;

public class PriorityQueue {
	/**
	 * An priority queue using an array-based ternary tree heap
	 */
	private final int INITIAL_CAPACITY = 7;
	private ProfileLink[] data;
	private int manyItems;
	private final Comparator<ProfileLink> COMP = new Comparator<ProfileLink>() {
		public int compare(ProfileLink a, ProfileLink b) {return a.cost - b.cost;}
	};


	private static boolean doReport = true;
	private boolean report(String message) {
		if (doReport) System.err.println("Invariant error: " + message);
		return false;
	}

	protected PriorityQueue(boolean ignored) {} // don't change: used by invariant checker
	
	
	private boolean wellFormed() {
		// TODO: Check invariant
		// 1. data array can't be null
		// 2. manyItems must be between 0 and data's length
		// 3. no null elements
		// 4. all children are larger than their parents
		
		if (data == null) {
			return report("data is null");
		} else if (manyItems<0 || manyItems>data.length) {
			return report("manyItems is incorrect");
		} 

		for (int i = 0; i < manyItems; i++) {
			if (data[i] == null) {
				return report("element is null");
			}
			if (!child(i)) {
				return report("children are not smaller than node");
			}
		}
		
		return true;
	}
	
	//TODO: optional helper method to check the children of a given node

	private boolean child(int i) {
		if ((left(i)) < data.length  && data[left(i)] !=null && 
				COMP.compare(data[i], data[left(i)]) > 0)
			return false;
		else if ((mid(i)) < data.length && data[mid(i)] !=null && 
				COMP.compare(data[i], data[mid(i)]) > 0)
			return false;
		else if ((right(i)) < data.length && data[right(i)] !=null && 
				COMP.compare(data[i], data[right(i)]) > 0)
			return false;
		return true;
	}

	/**
	 * Create a new PriorityQueue
	 */
	public PriorityQueue() {
		data = new ProfileLink[INITIAL_CAPACITY];
		assert wellFormed() : "invariant broken at end of constructor";
	}
	
	/**
	 * Add a ProfileLink to the PriorityQueue
	 * @param l the ProfileLink to be added
	 * @return true
	 * @throws IllegalArgumentException for null ProfileLink
	 */
	public boolean add(ProfileLink l) {
		// TODO: add a ProfileLink to the end of the array, and then bubble it up
		assert wellFormed(): "invariant failed at the start of add";
		if (l == null)
			throw new IllegalArgumentException("Profile link is null");
		
		if (manyItems+1>=data.length) ensureCapacity(manyItems+1);
		data[manyItems] = l;
		int i = manyItems;
		while (COMP.compare(data[i],data[parent(i)])<0) {
			swap(i, parent(i));
			i = parent(i);
		}
		manyItems++;
		
		assert wellFormed(): "invariant failed at the end of add";
		return true;
	}
	
	/**
	 * Remove and return the smallest ProfileLink from the PriorityQueue
	 * @return the smallest ProfileLink, now removed
	 * @throws NoSuchElementException if empty
	 */
	public ProfileLink remove() {
		//TODO: remove and return the first Profile Link
		//    replace it with the last ProfileLink
		//    and then bubble it down
		if (isEmpty()) throw new NoSuchElementException("Nothing to remove");
		assert wellFormed(): "invariant failed at the start of remove";
		ProfileLink returning = data[0];
		data[0]=data[manyItems-1];
		data[manyItems-1]=null;
		bubbleDown(0);
		manyItems--;
		assert wellFormed(): "invariant failed at the end of remove";
		return returning;
	}
	
	/**
	 * Return the size of the PriorityQueue
	 * @return the number of elements
	 */
	public int size() {
		return manyItems;
	}
	
	/**
	 * Check if the PriorityQueue is empty
	 * @return whether the PriorityQueue is empty
	 */
	public boolean isEmpty() {
		if (manyItems==0) return true;
		return false;
	}
	
	@Override
	public String toString() {
		return Arrays.toString(data);
	}
	
	private void ensureCapacity(int minimumCapacity)
	{
		ProfileLink [] newArray;
		if(data.length < minimumCapacity)
		{
			int newCapacity = data.length *2;
			if(newCapacity < minimumCapacity)
				newCapacity = minimumCapacity;
			newArray = new ProfileLink[newCapacity];
			for(int i=0; i<manyItems; i++)
				newArray[i] = data[i];
			data = newArray;
		}
	}
	
	// TODO: optional helper methods
	private void bubbleDown(int i) {
		if (i >= data.length || data[i] == null) {
			return;
		}
		if (COMP.compare(data[i], data[parent(i)]) < 0) {
			swap(i, parent(i));
		}
		bubbleDown(left(i));
		bubbleDown(mid(i));
		bubbleDown(right(i));

	}
	private void swap(int x, int y) 
    { 
       ProfileLink tmp; 
        tmp = data[x]; 
        data[x] = data[y]; 
        data[y] = tmp; 
    } 	
	private int parent(int i) { return (i-1)/3;}
	private int left(int i) { return i*3+1;}
	private int mid(int i) { return i*3+2;}
	private int right(int i) { return i*3+3;}
	
	public static class TestInvariant extends TestCase {
		private static final String[] TO_LOG = new String[] {"./src/edu/uwm/cs351/PriorityQueue.java"};
		private static boolean firstRun = true;
		
		public void log() {
			System.out.println("running");
			Snapshot.capture(TO_LOG);
		}
		
		PriorityQueue self;
		Profile a = new Profile("a");
		Profile b = new Profile("b");
		Profile c = new Profile("c");
		
		private ProfileLink l(int i) {
			return new ProfileLink(null, null, i);
		}

		@Override
		public void setUp() {
			if(firstRun) {
				log();
				firstRun = false;
			}
			self = new PriorityQueue(false);
		}
		
		public void testNull() {
			assertFalse(self.wellFormed());
			self.manyItems = 0;
			assertFalse(self.wellFormed());
		}

		public void testEmpty() {
			self.data = new ProfileLink[0];
			self.manyItems = 0;
			assertTrue(self.wellFormed());
			self.manyItems = -1;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertFalse(self.wellFormed());
		}
		
		public void testNullElements() {
			self.data = new ProfileLink[1];
			self.manyItems = 1;
			assertFalse(self.wellFormed());
			self.data = new ProfileLink[3];
			self.data[0] = new ProfileLink(a, b);
			self.data[2] = new ProfileLink(b, c);
			self.manyItems = 2;
			assertFalse(self.wellFormed());
			self.manyItems = 3;
			assertFalse(self.wellFormed());
			self.manyItems = 1;
			assertTrue(self.wellFormed());
		}
		
		public void testSmall() {
			self.data = new ProfileLink[2];
			self.data[0] = l(1);
			self.data[1] = l(1);
			self.manyItems = 2;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertTrue(self.wellFormed());
			self.data[1] = l(0);
			assertFalse(self.wellFormed());
		}
		
		public void testMedium() {
			self.data = new ProfileLink[4];
			self.data[0] = l(3);
			self.data[1] = l(8);
			self.data[2] = l(5);
			self.data[3] = l(12);
			self.manyItems = 4;
			assertTrue(self.wellFormed());
			self.data[1] = l(2);
			assertFalse(self.wellFormed());
			self.data[1] = l(12);
			self.data[2] = l(1);
			assertFalse(self.wellFormed());
			self.data[2] = l(11);
			self.data[3] = l(1);
			assertFalse(self.wellFormed());
			self.data[3] = l(4);
			assertTrue(self.wellFormed());
		}
		
		public void testLarge() {
			self.data = new ProfileLink[21];
			
			self.data[0] = l(5);
			
			self.data[1] = l(11);
			self.data[2] = l(88);
			self.data[3] = l(14);

			self.data[4] = l(12);
			self.data[5] = l(36);
			self.data[6] = l(22);
			self.data[7] = l(89);
			self.data[8] = l(100);
			self.data[9] = l(99);
			self.data[10] = l(53);
			self.data[11] = l(15);
			self.data[12] = l(15);

			self.data[13] = l(13);
			self.data[14] = l(13);
			self.data[15] = l(14);
			self.data[16] = l(65);
			self.data[17] = l(39);
			self.data[18] = l(44);
			
			self.manyItems = 19;
			assertTrue(self.wellFormed());
			self.data[7] = l(86);
			assertFalse(self.wellFormed());
			self.data[7] = l(89);
			self.data[8] = l(86);
			assertFalse(self.wellFormed());
			self.data[8] = l(100);
			self.data[9] = l(86);
			assertFalse(self.wellFormed());
			self.data[9] = l(99);
			

			self.data[16] = l(35);
			assertFalse(self.wellFormed());
			self.data[16] = l(65);
			self.data[17] = l(35);
			assertFalse(self.wellFormed());
			self.data[17] = l(39);
			self.data[18] = l(35);
			assertFalse(self.wellFormed());
			self.data[18] = l(44);
			
			self.data[4] = l(14);
			assertFalse(self.wellFormed());
			self.data[4] = l(12);
			self.data[5] = l(40);
			assertFalse(self.wellFormed());
			self.data[5] = l(36);
			
			self.data[0] = l(11);
			assertTrue(self.wellFormed());
		}
	}

}
